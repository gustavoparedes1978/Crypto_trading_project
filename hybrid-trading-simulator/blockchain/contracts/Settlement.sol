// SPDX-License-Identifier: MIT
// This license identifier is a best practice, ensuring the code's open-source license is clear.
pragma solidity ^0.8.20;

// Importing standard contracts from OpenZeppelin for security and reliability.
// ERC20 provides the core token functionality (e.g., transfer, balance).
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
// Ownable adds ownership-based access control, allowing only the owner to call certain functions.
import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title MockERC20
 * @dev A simplified ERC20 token for simulation and testing purposes.
 * It's not intended for production but for a controlled test environment.
 */
contract MockERC20 is ERC20, Ownable {
    // The constructor initializes the token with a name and symbol, and sets the initial owner.
    constructor(string memory name, string memory symbol, address initialOwner) ERC20(name, symbol) Ownable(initialOwner) {}

    /**
     * @dev Mints a specified amount of tokens and assigns them to an address.
     * @param to The address to receive the minted tokens.
     * @param amount The number of tokens to mint.
     * The `onlyOwner` modifier ensures that only the contract's owner can call this function,
     * preventing unauthorized token creation.
     */
    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }
}

/**
 * @title Settlement
 * @dev This contract acts as the on-chain settlement layer for a hybrid trading system.
 * It's designed to securely transfer assets between a buyer and a seller after an off-chain
 * matching engine has confirmed a trade.
 * The use of `onlyOwner` ensures that only a trusted backend service can trigger a settlement.
 */
contract Settlement is Ownable {
    // A mapping to keep track of settled trades to prevent a trade from being processed more than once.
    mapping(string => bool) private settledTrades;
    
    // Public variables to store the addresses of the two ERC20 token contracts involved in a trade.
    MockERC20 public tokenA; // e.g., a stablecoin like USDT
    MockERC20 public tokenB; // e.g., an asset like WBTC

    // An event that is emitted upon successful trade settlement.
    // Events provide a log on the blockchain that off-chain applications can listen to.
    event TradeSettled(string tradeId, address indexed buyer, address indexed seller, uint256 price, uint256 amount);

    /**
     * @dev The constructor for the Settlement contract.
     * @param initialOwner The address of the trusted backend service that will manage settlements.
     * @param _tokenA The address of the first ERC20 token contract.
     * @param _tokenB The address of the second ERC20 token contract.
     */
    constructor(address initialOwner, MockERC20 _tokenA, MockERC20 _tokenB) Ownable(initialOwner) {
        tokenA = _tokenA;
        tokenB = _tokenB;
    }

    /**
     * @dev Settles a trade by transferring assets between the buyer and seller.
     * This function is the core logic for on-chain settlement.
     * @param tradeId A unique identifier for the trade, typically generated by the matching engine.
     * @param buyer The address of the buyer.
     * @param seller The address of the seller.
     * @param price The price of the trade in tokenA units (e.g., USD).
     * @param amount The amount of tokenB being traded.
     * The `onlyOwner` modifier restricts access to this function to prevent unauthorized settlements.
     */
    function settleTrade(string memory tradeId, address buyer, address seller, uint256 price, uint256 amount) public onlyOwner {
        // A crucial security check to prevent double-settlement of a single trade.
        require(!settledTrades[tradeId], "Trade already settled");
        // Basic validation to ensure a valid trade has a positive price and amount.
        require(price > 0 && amount > 0, "Price and amount must be positive");

        // Calculate the total value of the trade in tokenA units.
        uint256 valueUSD = price * amount;

        // --- Execute the token transfers ---
        // 1. Transfer the value of tokenA from the buyer to the seller.
        //    This assumes the buyer has already approved this contract to spend their tokenA.
        tokenA.transferFrom(buyer, seller, valueUSD);

        // 2. Transfer the amount of tokenB from the seller to the buyer.
        //    This assumes the seller has already approved this contract to spend their tokenB.
        tokenB.transferFrom(seller, buyer, amount);

        // Mark the trade ID as settled to prevent it from being processed again.
        settledTrades[tradeId] = true;
        // Emit an event to log the settlement details on the blockchain.
        emit TradeSettled(tradeId, buyer, seller, price, amount);
    }
}